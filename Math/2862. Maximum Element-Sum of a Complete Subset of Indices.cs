//Leetcode 2862. Maximum Element-Sum of a Complete Subset of Indices hard
//题意：你给出一个从1开始索引的数组nums。
//你的任务是从nums中选择一个完整的子集，使得所选索引的每一对乘积都是一个完全平方数。
//换句话说，如果你选择了nums中的第i和第j个元素，那么i* j必须是一个完全平方数。
//返回具有最大和的完整子集的和。
//思路：我们分析一下“任意两个下标i与j的乘积是完全平方数”的含义。
//我们将i分解为i=a*x^2，其中x^2是i里包含的最大平方因子。
//同理，分解j=b*y^2。为了使得i*j依然是平方数，那么必然要求a==b. 
//同理，与{i,j}属于同一个集合里的其他下标元素，必然也必须能分解为a*z^2的形式。
//所以为了最大化这个集合（不仅指集合元素的数目，也指element-sum），
//集合元素里的那些“最大平方因子”必然是1^2, 2^2, 3^3, 4^2 ... 直至n。
//然后我们再穷举a=1,2,3.... 就可以构造出所有可能的最优集合，即
//1*1, 1*4，1*9, 1*16, ...
//2*1, 2*4，2*9, 2*16, ...
//3*1, 3*4，3*9, 3*16, ...
//直至集合最小元素的上限是n。        
//对于*1而言，我们穷举了n次。对于*4而言，我们穷举了n/4次。对于*9而言，我们穷举了n/9次。
//所以总的穷举数目为n/1 + n/4 + n/9 + ...，它是和小于2n的序列。故总的时间复杂度是o(N).
//时间复杂度：O(n)
//空间复杂度：O(1)
        public long MaximumSum(IList<int> nums)
        {
            int n = nums.Count;
            int k = 1;
            long res = 0;
            //在穷举的时候，固定k，然后每一个都是k*1^2 + k*2^2....依此类推，保证每次都是完美平方数；
            while (k <= n)
            {
                long sum = 0;
                for(int i = 1; k * i * i <= n; i++)
                {
                    sum += nums[k * i * i - 1];
                }
                res = Math.Max(res, sum);
                k++;
            }
            return res;
        }