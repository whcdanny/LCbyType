//Leetcode 924. Minimize Malware Spread hard
//题意：给定一个计算机网络，其中的节点表示计算机，边表示连接。初始时，一些节点被感染，表示为 malware 数组中的节点。我们可以通过删除某些边来尽量减少恶意软件的传播，但是删除的边数不能超过 K。要求找到一种删除方式，使得删除的边数最小，并且在删除边后，感染节点的数量不发生变化，或者变化最小。
//思路：使用 BFS 找到每个感染联通分量的大小。遍历 malware 数组，找到恶意软件所在的联通分量以及每个联通分量的节点数。统计每个不同联通分量中的感染节点数量，并记录联通分量的节点总数。遍历联通分量，如果该联通分量只有一个感染节点，说明删除该联通分量的所有边都可以使得感染节点数减少，返回该联通分量的节点数。如果该联通分量有多个感染节点，但是其中的某个感染节点的删除会导致感染节点数减少，同样返回该联通分量的节点数。如果以上情况都不满足，返回 malware 数组中的第一个节点的数量。
//时间复杂度: 使用 BFS 遍历整个图，时间复杂度为 O(N^2)，其中 N 为节点数量。遍历 malware 数组，时间复杂度为 O(N)。统计联通分量信息，时间复杂度为 O(N)。统计不同联通分量中的感染节点数量，时间复杂度为 O(N)。遍历联通分量，时间复杂度为 O(N)。总的时间复杂度为 O(N^2)。
//空间复杂度：使用数组记录感染节点信息，空间复杂度为 O(N)。使用集合记录感染节点所在的联通分量，空间复杂度为 O(N)。使用数组记录联通分量信息，空间复杂度为 O(N)。使用数组记录不同联通分量中的感染节点数量，空间复杂度为 O(N)。总的空间复杂度为 O(N)。
        public int MinMalwareSpread(int[][] graph, int[] initial)
        {
            int n = graph.Length;
            int[] colors = new int[n];
            Array.Fill(colors, -1);

            int color = 0;
            Dictionary<int, int> size = new Dictionary<int, int>();

            for (int i = 0; i < n; i++)
            {
                if (colors[i] == -1)
                {
                    BFS_MinMalwareSpread(graph, colors, i, color, size);
                    color++;
                }
            }

            int[] colorCount = new int[color];
            foreach (int node in initial)
            {
                colorCount[colors[node]]++;
            }

            int result = Int32.MaxValue;
            int maxInfected = 0;

            foreach (int node in initial)
            {
                int currentColor = colors[node];
                int currentInfected = colorCount[currentColor] == 1 ? size[currentColor] : 0;

                if (currentInfected > maxInfected || (currentInfected == maxInfected && node < result))
                {
                    result = node;
                    maxInfected = currentInfected;
                }
            }

            return result;
        }
        private void BFS_MinMalwareSpread(int[][] graph, int[] colors, int start, int color, Dictionary<int, int> size)
        {
            Queue<int> queue = new Queue<int>();
            queue.Enqueue(start);
            colors[start] = color;
            int currentSize = 0;

            while (queue.Count > 0)
            {
                int current = queue.Dequeue();
                currentSize++;

                for (int neighbor = 0; neighbor < graph[current].Length; neighbor++)
                {
                    if (graph[current][neighbor] == 1 && colors[neighbor] == -1)
                    {
                        queue.Enqueue(neighbor);
                        colors[neighbor] = color;
                    }
                }
            }

            size[color] = currentSize;
        }