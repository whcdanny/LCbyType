//Leetcode 3022. Minimize OR of Remaining Elements Using Operations hard
//题意：给出了一个整数数组 nums 和一个整数 k。
//每一次操作，你可以选择数组中任意一个索引 i，其中 0 <= i<nums.length - 1，
//然后将 nums[i] 和 nums[i + 1] 替换为 nums[i] & nums[i + 1]，其中 & 表示按位与运算符。
//要求返回应用最多 k 次操作后，剩余元素的按位或（OR）的最小可能值。
//思路：贪婪算法：本题的时间复杂度要求o(n)，单纯用one pass很难求解。
//此时可以考虑到引入常数量，来适当松弛时间复杂度的要求。
//任何一个数字的二进制位不超过30，那么可以尝试类似o(30n)的解法。
//考虑最高位，我们希望最终结果是0的话，那么意味着你需要将数组分割成若干个区间，每个区间内的AND结果都是0（这样，区间彼此之间的OR的结果才能是0）。
//分割方法可能有很多种，但是我们并不需要关心具体的操作，只需要判定“能否实现”即可。
//用贪心法解决。从左往右依次处理，如果有非零元素，那么我们必然将其与右边的元素进行AND操作，重复进行直至变成0。
//此时所扫过的区间就是我们想要的一个最小区间。因为我们有贪心的思想：分割的每个区间越小，即总区间的数目越多，就意味着我们需要的AND操作最少。
//这是因为AND的总操作数本质就是n减去区间的数目。
//用上述的方法，判定出“最高位不能够构造出0”，那么我们就直接将result的最高位放置1即可。
//在后续的分析中，我们都不需要考虑nums数组里任何元素的最高位。
//它们不会对我们后续的构造（即区间分割）带来负面的“牵制”，即任何区间分割的方法都不会使得result的最高位能变成0。
//用上述的方法，判定出“最高位能够构造出0”，此时需要注意：符合条件的分割可能有很多种策略，但不关心具体的操作，因为最优的分割需要结合到次高位的制约。
//接下来就考察次高位，依然是尝试判断“能否在该位构造出0”。
//这时候我们要注意，因为贪心，我们必须仍然要保持最高位的结果是0，同时也希望次高位的结果也是0，所以本质就是判断“仅考虑最高的两个bit位的前提下，能否将数组分割成若干个区间，每个区间内的AND结果都是00”。
//如果是true，就意味着最终result的次高位也直接置0，否则最终result的次高位置1.
//接下来，重复策略，如果刚才的结论是true，我们接下来会尝试能否在最高的三位构造出000；
//如果是false，那么之后的考察就要忽略掉所有元素的次高位（任何分割都不会是的result的次高位变成0）。
//通过查看数组能否被分割成若干个AND为0的区间，可以从高到低判定是否能在result里的每个bit上置零。
//如果不能，记得将nums里所有元素的该bit位直接划去。
//时间复杂度: O(n)
//空间复杂度：O(n)
        public int MinOrAfterOperations(int[] nums, int k)
        {
            int n = nums.Length;
            //每个nums被选择的比特位；
            int[] arr = new int[n];
            int res = 0;
            //从高位开始找是否可以是0；每一位比特位都试一下；
            for(int t = 29; t >= 0; t--)
            {
                //当前的arr添加当前nums[i]
                for(int i = 0; i < n; i++)
                {
                    //向左移动一位；然后添加-》i在第t位的比特数字就是（向右移动t位再跟1比）
                    arr[i] = (arr[i] << 1) + ((nums[i] >> t) & 1);
                }
                //在arr中贪心法，找的是否能位0；
                if(checkOK_MinOrAfterOperations(arr, k))
                {
                    //向做移动一位添加一个0；
                    res = res * 2 + 0;
                }
                else
                {
                    res = res * 2 + 1;
                    //失败了所以就删掉了
                    for(int i = 0; i < n; i++)
                    {
                        arr[i] = (arr[i] >> 1);
                    }
                }
            }
            return res;
        }

        private bool checkOK_MinOrAfterOperations(int[] arr, int k)
        {
            int n = arr.Length;
            int count = 0;
            int i = 0;
            while (i < n)
            {
                int cur = arr[i];
                int j = i;
                while (cur != 0)
                {
                    count++;
                    j++;
                    if (j == n)
                        break;
                    cur &= arr[j];
                }
                i = j + 1;
            }
            //如果在最后一个的时候，j会+1，所以不要越界；
            return (count != n && count <= k);
        }