//Leetcode 233. Number of Digit One hard
//题意：统计从 0 到给定整数 n 之间所有非负整数中出现的数字 1 的总数
//思路：其中比较清晰容易实现的思路是：逐位查看，看该位上为1的符合条件的整数有多少个，然后将该整数的个数累加进最后的答案。
//这样虽然看上去是在数整数的个数，但其实最终得到的就是digit为1的总个数。
//举个例子。考虑n=345Y78，（Y是任意的数，待定），我们想考察有多少个符合要求的整数，使得其百位上可以是1.
//(1) 如果前三位任取000-344之一（共345种可能），那么最低两位可以任意取00-99（共100种可能）都不会超过n。
//这样的数有345*100=34500个。第一个乘数就是n的前三位，第二个乘数就是10的二次方。
//(2) 如果前三位取345(不可能更大了)，我们就要考虑Y的影响。
//a.如果Y>1，那么最低两位可以任意取00-99（共100种可能）都不会超过n。这样的数有100个。
//b.如果Y==1，那么最低两位不可以随便取，只能取00-78（共79种可能）。这个数字就是n的末两位加上1.
//c.如果Y<1，那么最低两位如论取什么，都会导致这个数大于n，不符合条件。
//综合整理上述的分类讨论方案，可以将它适用于任何一个数位（个位、十位、千位、万位...），将这些数的统计全部加起来就是答案。
//时间复杂度: n
//空间复杂度：n;
        public int countDigitOne(int n)
        {
            string s = n.ToString();
            long len = s.Length;
            long count = 0;
            for (int i = 1; i <= len; i++)
            {
                long divisor = (long)Math.Pow(10, i);
                count += n / divisor * 1 * (long)Math.Pow(10, i - 1);
                int digit = s[(int)len - i] - '0';
                if (digit > 1)
                    count += (long)Math.Pow(10, i - 1);
                else if (digit == 1)
                    count += n % (int)Math.Pow(10, i - 1) + 1;
            }
            return (int)count;
        }