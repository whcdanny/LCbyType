//Leetcode 928. Minimize Malware Spread II hard
//题意：给定一个有向图graph，表示计算机网络中计算机之间的连接关系,比如graph[0][1]=1，表示0和1的服务器连接。恶意软件在某个计算机上发现后，它可能会传播到相邻的计算机。给了一个初始节点initial这里面有病毒，现在我们要找到一个节点，使得删除该节点后，网络中的恶意软件的传播受到最小的影响。
//思路：建图： 构建有向图的邻接矩阵，表示计算机之间的连接关系。然后从initial依此删除一个，然后用BFS来历遍找到虽小别感染的数量，这是这个被删除的节点就算最佳，并且如果3，0都可以，选择最小的；
//时间复杂度: 建图：O(N^2)，其中 N 是节点的数量。寻找联通分量：O(N^2)，同样 N 是节点的数量。统计联通分量中的节点数和边数：O(N^2)。找到影响最小的节点：O(N^2)。
//空间复杂度：O(N)
        public int MinMalwareSpread(int[][] graph, int[] initial)
        {
            int n = graph.Length;            
            Dictionary<int, List<int>> map = new Dictionary<int, List<int>>();
            for(int i = 0; i < n; i++)
            {
                map[i] = new List<int>();
            }
            for(int i = 0; i < n; i++)
            {
                for(int j = 0; j < n; j++)
                {
                    if (graph[i][j] == 1 && i!=j)
                    {                        
                        map[i].Add(j);
                    }                    
                }
            }
            int res = int.MaxValue;
            int min = int.MaxValue;
            foreach(int index in initial)
            {
                Queue<int> queue = new Queue<int>();
                HashSet<int> visited = new HashSet<int>();
                for (int i = 0; i < initial.Length; i++)
                {
                    if (index != initial[i])
                    {
                        queue.Enqueue(initial[i]);
                        visited.Add(initial[i]);
                    }                       
                }

                while (queue.Count > 0)
                {
                    int count = queue.Count;
                    for(int j = 0; j < count; j++)
                    {
                        int node = queue.Dequeue();
                        foreach(var nig in map[node])
                        {
                            if (!visited.Contains(nig) && nig!=index)
                            {
                                queue.Enqueue(nig);
                                visited.Add(nig);
                            }
                        }
                    }
                }
                if (min > visited.Count)
                {
                    min = visited.Count;
                    res = index;
                }
                if (min == visited.Count)
                    res = Math.Min(res, index);
            }
            return res;
        }