//Leetcode 1040. Moving Stones Until Consecutive II med
//题意：在 X 轴上有一些石头，你被给定一个整数数组 stones 表示这些石头的位置。
//定义一个石头是“端点石头”如果它有最小或最大的位置。在一次移动中，你可以选择一个端点石头并将其移动到一个未被占据的位置，使得它不再是端点石头。
//特别地，如果石头的位置是 stones = [1, 2, 5]，你不能移动位置在 5 的端点石头，因为将其移动到任何位置（比如 0 或 3）仍然会保持它作为端点石头。游戏结束的条件是不能再进行任何移动（即石头位于三个连续的位置）。
//返回一个长度为 2 的整数数组 answer：
//answer[0] 是你可以进行的最小移动次数。
//answer[1] 是你可以进行的最大移动次数。
//注：说白了移动任何点使其成为连续的增长的数组；
//思路：滑块和双指针，
//先排序，然后看comment；
//时间复杂度：O(NlogN)，其中 N 是石头的数量，主要由排序操作决定。
//空间复杂度：O(1)
        public int[] NumMovesStonesII(int[] stones)
        {
            Array.Sort(stones);

            int i = 0, n = stones.Length;
            //相当于头和尾 不能添加在当前数组的头尾，比如 2 3 10， 2不可以取1或者11，同理，10不能1或者4，因为条件你不能让一个头或尾端点在成为一个端点，
            //我们用滑块，因为大小就是stones的长度，所以对于我们找最大步骤就是让头去做靠近尾部位置，尾部去做靠近头部位置
            //对于头我们不能再移动到末尾也不能再是头（n-2），所以找倒数第二个数的位置到stones[n - 2] - stones[0] - （n-2）；
            //同理，对于尾我们不能再移动到末尾也不能再是头（n-2），所以找到第二个开始的位置stones[n - 1] - n + 2 - stones[1]；
            int high = Math.Max(stones[n - 1] - n + 2 - stones[1], stones[n - 2] - stones[0] - n + 2);

            int low = n;
            for (int j = 0; j < n; j++)
            {
                //因为滑块只有n 如果等于或超过 说明i和j之间大了 需要缩小 所以i++；
                while (stones[j] - stones[i] >= n) i++;

                //在两个端点的石头之间只有一个空隙的情况下。这样的情况下，我们只需要移动两次，将一个端点的石头放到空隙中，然后再移动一次将另一个端点的石头放到这个空隙中，即可完成。
                if (j - i + 1 == n - 1 && stones[j] - stones[i] == n - 2) 
                    low = Math.Min(low, 2);
                //其他情况就看双指针之间的距离并用n减去；
                else 
                    low = Math.Min(low, n - (j - i + 1));
            }
            return new int[] { low, high };
        }