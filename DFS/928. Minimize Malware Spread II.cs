//Leetcode 928. Minimize Malware Spread II hard
//题意：给定一个有向图graph，表示计算机网络中计算机之间的连接关系,比如graph[0][1]=1，表示0和1的服务器连接。恶意软件在某个计算机上发现后，它可能会传播到相邻的计算机。
//给了一个初始节点initial这里面有病毒，现在我们要找到一个节点，使得删除该节点后，网络中的恶意软件的传播受到最小的影响。
//思路：建图： 构建有向图的邻接矩阵，表示计算机之间的连接关系。然后从initial依此删除一个，然后用BFS来历遍找到虽小别感染的数量，这是这个被删除的节点就算最佳，并且如果3，0都可以，选择最小的；
//时间复杂度: O(V * (V + E))，其中 V 为节点数，E 为边数
//空间复杂度：O(N)
        public int MinMalwareSpread(int[][] graph, int[] initial)
        {
            int max = -1, ans = 0;
            bool[] virus = new bool[graph.Length];
            Array.Sort(initial); 
            foreach (int v in initial) 
                virus[v] = true;
            foreach (int v in initial)
            {
                int res = dfs(graph, v, v, new bool[graph.Length], virus);
                if (res > max)
                {
                    max = res;
                    ans = v;
                }
            }

            return ans;
        }
        //统计从节点 cur 出发，不考虑被感染节点的情况下，能够到达的节点数
        public int dfs(int[][] graph, int start, int cur, bool[] visited, bool[] virus)
        {
            if (visited[cur]) return 0;
            //表示当前分支是不好的
            if (virus[cur] && start != cur) return -1000; //this branch is bad.
            visited[cur] = true;

            int sz = 0, tmp = 0;
            for (int i = 0; i < graph.Length; i++)
            {
                if (graph[cur][i] == 1)
                {
                    tmp = dfs(graph, start, i, visited, virus);
                    sz = (start == cur ? sz + Math.Max(tmp, 0) : sz + tmp);
                    //only take the max(0, tmp) when it returns to the first call.
                }
            }

            return sz + 1;
        }