//Leetcode 2939. Maximum Xor Product med
//题意：给定三个整数 a, b 和 n，返回 (a XOR x) * (b XOR x) 的最大值，其中 0 <= x < 2^n。
//由于答案可能非常大，返回结果对 10^9 + 7 取模。
//注意：XOR 是按位异或操作。
//思路：显然最贪心的策略是，
//首先考虑XOR只是位操作，bit之间互不影响，所以我们考察一下所有位操作的可能：找出规律
//a:   0, 0, || 1, 1, || 1, 1, || 0, 0
//b:   1, 1, || 0, 0, || 1, 1, || 0, 0
//x:   0, 1, || 0, 1, || 0, 1, || 0, 1
//-----------
//a^x: 0, 1, || 1, 0, || 1, 0, || 0, 1
//b^x: 1, 0, || 0, 1, || 1, 0, || 0, 1
// G G     G G     G B     B G
//为了使得每个bit位上的(a^x)*(b^x)最大，我们总结出如下规律：
//如果a与b的bit值不同（即一个0一个1），不管如何设置x，都会使得a^x与b^x其中一个是0且令一个是1.
//如果a与b的bit值相同，那么最优的x是取与其相反的数值，使得a^x与b^x都是1（因为让两者都是0显然不是最优策略）.
//对于第一种情况，我们还需要确定，究竟是让a^x是1，还是让b^x是1.此时我们发现，无论做何选择，a^x + b^x总是固定的。
//这样一个定理：在sum固定的情况下，想让两个元素的积最大，我们必然希望这两个元素尽量相等。
//为了实现这个目标，我们可以在第一次时给a^x赋1，之后都给b^x赋1，以此实现最大化的(a^x)*(b^x).
//注意，以上的分析要求x能覆盖a与b的所有bit位。
//事实上x有限制范围，最多只能设置n个比特位。
//如果n可以覆盖所有a,b的bit位，那么就根据之前的规律，
//如果bit位相同,就把当前bit位改成1，
//如果bit位不相同，先把a的第一个出现的不同位的改成1，然后剩下的都改成0，b的对应位置第一个是0，剩下的是1，原因就是sum固定的情况下，想让两个元素的积最大，我们必然希望这两个元素尽量相等。
//如果n不可以覆盖所有a,b的bit位在这种情况下，只要确定a,b中谁比较大，
//如果bit位相同,就把当前bit位改成1，
//如果bit位不相同, 哪个数字大，就改成0，那么数字小就改成1；
//时间复杂度：O(n)
//空间复杂度：O(1)
        public int MaximumXorProduct(long a, long b, int n)
        {
            long M = 1000000007;
            //首先我们通过右移n位并再左移n位来得到A和B的值。这一步的目的是确保我们只关注a和b的高n位部分。
            long A = ((a >> n) << n);
            long B = ((b >> n) << n);

            //我们交换a和b并重新调用函数。这是因为我们希望A总是大于或等于B。
            if (A < B)
                return MaximumXorProduct(b, a, n);

            //相当于n可以覆盖的所有bit位；
            if (A == B)
            {
                bool flag = false;
                for (int k = n - 1; k >= 0; k--)
                {
                    long bit1 = ((a >> k) & 1L);
                    long bit2 = ((b >> k) & 1L);
                    if (bit1 == bit2)
                    {
                        a = a - (bit1 << k) + (1L << k);
                        b = b - (bit2 << k) + (1L << k);
                    }
                    else
                    {
                        //需要先找到最高不相同的bit位，然后要A大，那么就只把当前A的bit位改成1，B的bit位改成0；
                        //之和就是A>B
                        if (!flag)
                        {
                            a = a - (bit1 << k) + (1L << k);
                            b = b - (bit2 << k);
                            flag = true;
                        }
                        else
                        {
                            a = a - (bit1 << k);
                            b = b - (bit2 << k) + (1L << k);
                        }
                    }
                }
            }
            //n不能覆盖的所有A,B的bit位，这样高的能覆盖的位置，都改成0，低的都改成1；
            if (A > B)
            {
                for (int k = n - 1; k >= 0; k--)
                {
                    long bit1 = ((a >> k) & 1L);
                    long bit2 = ((b >> k) & 1L);
                    if (bit1 == bit2)
                    {
                        //把原来k位的bit扣掉，然后改成1；
                        a = a - (bit1 << k) + (1L << k);
                        b = b - (bit2 << k) + (1L << k);
                    }
                    else
                    {
                        //因为A>B,所以强制A的bit1改成0，B的bit2改成1；
                        //因为在sum和相同的情况下，两个数越接近，乘积越大，所以要B尽可能接近A；
                        a = a - (bit1 << k);
                        b = b - (bit2 << k) + (1L << k);
                    }
                }
            }

            return (int)(((a % M) * (b % M)) % M);
        }